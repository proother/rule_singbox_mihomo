name: Convert Workflow

on:
  push:
    branches:
      - main
  workflow_dispatch:
  schedule:
    - cron: '0 12 * * *'

permissions:
  contents: write

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
      #
      # 1. Set variables
      #
      - name: Set variables
        shell: bash
        run: |
          echo "GOAMD64=v3" >> $GITHUB_ENV
          echo "BUILDTIME=$(TZ=Asia/Shanghai date +'%Y-%m-%d %H:%M')" >> $GITHUB_ENV
          echo "TAG_NAME=$(TZ=Asia/Shanghai date +'%Y%m%d-%H%M')" >> $GITHUB_ENV

      #
      # 2. Check out repositories
      #
      - name: Checkout blackmatrix7/ios_rule_script
        uses: actions/checkout@v4
        with:
          repository: blackmatrix7/ios_rule_script
          path: ios_rule_script

      - name: Checkout MetaCubeX/meta-rules-converter
        uses: actions/checkout@v4
        with:
          repository: MetaCubeX/meta-rules-converter
          path: converter

      - name: Checkout Loyalsoldier/domain-list-custom
        uses: actions/checkout@v4
        with:
          repository: Loyalsoldier/domain-list-custom
          path: custom

      #
      # 3. Setup Go
      #
      - name: Setup Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.22'
          cache-dependency-path: ./custom/go.sum

      #
      # 4. Copy files to data source directory
      #
      - name: Copy files to data source directory
        run: |
          echo "=== Copying necessary files to data source directory ==="
          mkdir -p community/data_source

          # Copy .yaml files
          echo "=== Copying .yaml files ==="
          for dir in $(find ios_rule_script/rule/Clash -type d); do
            if ls "$dir"/*_Classical.yaml 2>/dev/null; then
              find "$dir" -type f -name '*_Classical.yaml' ! -name '*_No_Resolve.yaml' -exec cp {} community/data_source/ \;
            else
              dir_name=$(basename "$dir")
              find "$dir" -type f -name "${dir_name}.yaml" ! -name '*_No_Resolve.yaml' -exec cp {} community/data_source/ \;
            fi
          done

          echo "=== Files in community/data_source ==="
          ls -al community/data_source

      #
      # 5. Convert YAML to sing rules (Updated Step)
      #
      - name: Convert YAML to sing rules
        run: |
          echo "=== Converting .yaml to sing rules ==="
          mkdir -p sing-rule
          cd converter
          # Build the converter
          go build -o meta-converter .
          # Use the built binary
          ./meta-converter clash -f ../community/data_source -o ../sing-rule -t sing-box
          cd ../sing-rule

          # Move files from subdirectories to the root of sing-rule
          for dir in */; do
            dir_name=$(basename "$dir")
            if [[ -f "$dir/classical.json" && -f "$dir/classical.srs" ]]; then
              # Find the original YAML file in community/data_source
              original_yaml=$(find ../community/data_source -type f -iname "${dir_name}.yaml" -print -quit)

              if [[ -n "$original_yaml" ]]; then
                # Extract the original filename (without extension)
                original_name=$(basename "$original_yaml" .yaml)

                # Move and rename the JSON/SRS files to match the original filename
                mv "$dir/classical.json" "${original_name}.json"
                mv "$dir/classical.srs" "${original_name}.srs"
              else
                # Fallback to directory name if original YAML is not found
                mv "$dir/classical.json" "${dir_name}.json"
                mv "$dir/classical.srs" "${dir_name}.srs"
              fi
            fi
            # Remove the empty subdirectory
            rm -rf "$dir"
          done

          echo "=== Final files in sing-rule ==="
          ls -al

      #
      # 5.5. Create lite sing-box rules (IP-CIDR + DOMAIN only)
      #
      - name: Create lite sing-box rules
        run: |
          echo "=== Creating lite rules (IP-CIDR + DOMAIN only) ==="
          mkdir -p sing-rule-lite
          
          # Install jq for JSON processing
          sudo apt-get update && sudo apt-get install -y jq
          
          # Process each JSON file in sing-rule directory
          for json_file in sing-rule/*.json; do
            if [[ -f "$json_file" ]]; then
              filename=$(basename "$json_file" .json)
              echo "Processing $filename for lite version..."
              
              # Filter rules to keep ONLY ip_cidr and domain fields - defensive approach
              jq '
                {
                  version: .version,
                  rules: [
                    .rules[] | 
                    # Build new object explicitly with ONLY allowed fields
                    # This guarantees no other fields can appear
                    with_entries(select(.key == "ip_cidr" or .key == "domain")) |
                    # Only keep rules that have at least one of our target fields
                    select(keys | length > 0)
                  ]
                }
              ' "$json_file" > "sing-rule-lite/${filename}.json"
              
              # Check if the filtered file has any rules
              rule_count=$(jq '.rules | length' "sing-rule-lite/${filename}.json")
              if [[ "$rule_count" -eq 0 ]]; then
                echo "No lite rules found in $filename, removing empty file"
                rm "sing-rule-lite/${filename}.json"
              else
                echo "Created ${filename}.json with $rule_count rules"
              fi
            fi
          done
          
          echo "=== Converting lite JSON to SRS format ==="
          
          # Create a temporary directory structure for meta-converter
          echo "Preparing directory structure for meta-converter..."
          mkdir -p lite-temp
          
          # Copy each lite JSON to a subdirectory (mimicking the original structure)
          for lite_json in sing-rule-lite/*.json; do
            if [[ -f "$lite_json" ]]; then
              filename=$(basename "$lite_json" .json)
              mkdir -p "lite-temp/$filename"
              cp "$lite_json" "lite-temp/$filename/classical.json"
              echo "Prepared $filename for conversion"
            fi
          done
          
          # Use meta-converter to convert the entire lite-temp directory (same as complete rules)
          cd converter
          
          # Ensure meta-converter binary exists and is executable
          if [[ ! -f "./meta-converter" ]]; then
            echo "Building meta-converter..."
            go build -o meta-converter .
          fi
          
          # Make sure it's executable
          chmod +x ./meta-converter
          
          # Use absolute path to avoid conflicts with system 'convert' command
          CONVERTER_BINARY="$(pwd)/meta-converter"
          echo "Using meta-converter at: $CONVERTER_BINARY"
          echo "Running command: $CONVERTER_BINARY sing-box -f $(pwd)/../lite-temp -o $(pwd)/../sing-rule-lite-srs -t sing-box-srs"
          
          if "$CONVERTER_BINARY" sing-box -f "$(pwd)/../lite-temp" -o "$(pwd)/../sing-rule-lite-srs" -t sing-box-srs; then
            echo "✅ Meta-converter completed successfully"
            
            # Move SRS files back to sing-rule-lite directory with correct names
            cd ../sing-rule-lite-srs
            for dir in */; do
              if [[ -d "$dir" ]]; then
                dir_name=$(basename "$dir")
                if [[ -f "$dir/classical.srs" ]]; then
                  mv "$dir/classical.srs" "../sing-rule-lite/${dir_name}.srs"
                  echo "✅ Moved ${dir_name}.srs to lite directory"
                fi
              fi
            done
            cd ..
            
            # Clean up temporary directories
            rm -rf lite-temp sing-rule-lite-srs
            echo "✅ Cleanup completed"
          else
            echo "❌ Meta-converter failed!"
            cd ..
            
            # Debug information
            echo "=== Debugging meta-converter failure ==="
            echo "Current directory: $(pwd)"
            echo "Converter directory contents:"
            ls -la converter/
            echo "Lite-temp directory contents:"
            ls -la lite-temp/ 2>/dev/null || echo "lite-temp directory not found"
            
            # Clean up
            rm -rf lite-temp sing-rule-lite-srs
            
            echo "❌ CRITICAL: Meta-converter failed to generate SRS files"
            echo "This means no SRS files will be available for lite rules"
            echo "Only JSON files will be provided in the lite package"
          fi
          
          # Verify SRS files were created
          srs_count=$(find sing-rule-lite -name "*.srs" | wc -l)
          json_count=$(find sing-rule-lite -name "*.json" | wc -l)
          echo "=== SRS Conversion Summary ==="
          echo "JSON files: $json_count"
          echo "SRS files: $srs_count"
          
          if [[ "$srs_count" -lt "$json_count" ]]; then
            echo "⚠️  Warning: Some JSON files failed to convert to SRS"
          else
            echo "✅ All JSON files successfully converted to SRS"
          fi
          
          echo "=== Lite rules summary ==="
          echo "Total lite rule files created: $(find sing-rule-lite -name "*.json" | wc -l)"
          echo "Files with IP-CIDR and DOMAIN rules only:"
          
          # Validate that lite rules only contain ip_cidr and domain fields
          validation_failed=false
          for lite_file in sing-rule-lite/*.json; do
            if [[ -f "$lite_file" ]]; then
              filename=$(basename "$lite_file" .json)
              ip_count=$(jq '[.rules[] | select(has("ip_cidr"))] | length' "$lite_file")
              domain_count=$(jq '[.rules[] | select(has("domain"))] | length' "$lite_file")
              total_count=$(jq '.rules | length' "$lite_file")
              
              # Check for any unexpected fields in rules
              unexpected_fields=$(jq -r '[.rules[] | keys | .[] | select(. != "ip_cidr" and . != "domain")] | unique | .[]' "$lite_file" 2>/dev/null || true)
              
              if [[ -n "$unexpected_fields" ]]; then
                echo "  ❌ $filename: $total_count rules ($ip_count IP-CIDR, $domain_count DOMAIN) - UNEXPECTED FIELDS: $unexpected_fields"
                validation_failed=true
              else
                echo "  ✅ $filename: $total_count rules ($ip_count IP-CIDR, $domain_count DOMAIN) - CLEAN"
              fi
            fi
          done
          
          if [[ "$validation_failed" == "true" ]]; then
            echo "❌ VALIDATION FAILED: Some lite rules contain unexpected fields!"
            exit 1
          else
            echo "✅ VALIDATION PASSED: All lite rules contain only ip_cidr and domain fields"
          fi
          
          echo "=== Final lite files ==="
          ls -al sing-rule-lite/
          
          # Final verification of file counts
          final_json_count=$(find sing-rule-lite -name "*.json" | wc -l)
          final_srs_count=$(find sing-rule-lite -name "*.srs" | wc -l)
          echo "=== Final File Count Verification ==="
          echo "Total JSON files: $final_json_count"
          echo "Total SRS files: $final_srs_count"
          
          if [[ "$final_srs_count" -eq 0 ]]; then
            echo "⚠️  WARNING: No SRS files generated! Only JSON files will be available."
            echo "This is likely due to meta-converter failure, but JSON-only package is still functional."
            echo "Users can still use lite rules with format: 'source' instead of 'binary'"
          elif [[ "$final_srs_count" -lt "$final_json_count" ]]; then
            echo "⚠️  Warning: SRS count ($final_srs_count) is less than JSON count ($final_json_count)"
            echo "Some rules may not have SRS versions, but continuing..."
          else
            echo "✅ All good: Both JSON and SRS files are present"
          fi

      #
      # 6. Process YAML files for meta-rule
      #
      - name: Process YAML files for meta-rule
        run: |
          echo "=== Processing YAML files for meta-rule ==="
          mkdir -p meta-rule
          cp community/data_source/*.yaml meta-rule/
          
          echo "=== Removing comments and empty lines from YAML files ==="
          for yaml_file in meta-rule/*.yaml; do
            # Remove comments (lines starting with '#') and empty lines
            sed '/^#/d; /^$/d' "$yaml_file" > tmp && mv tmp "$yaml_file"
          done
          
          echo "=== Converting YAML to LIST files ==="
          for yaml_file in meta-rule/*.yaml; do
            list_file="${yaml_file%.yaml}.list"
            # Skip the first line, remove leading '- ' prefix, and eliminate empty lines
            tail -n +2 "$yaml_file" | sed 's/^[[:space:]]*-\s*//g' | grep -v '^$' > "$list_file"
          done
          
          echo "=== Final files in meta-rule ==="
          ls -al meta-rule

      #
      # 7. Gather artifacts into publish folder
      #
      - name: Prepare publish artifacts
        run: |
          echo "=== Collecting final artifacts into ./publish/ ==="
          mkdir -p publish

          # Move sing-rule, sing-rule-lite and meta-rule into publish/
          cp -r sing-rule publish/sing-rule
          cp -r sing-rule-lite publish/sing-rule-lite
          cp -r meta-rule publish/meta-rule
          echo "=== sing-rule file count: $(find sing-rule -type f | wc -l) ==="
          echo "=== sing-rule-lite file count: $(find sing-rule-lite -type f | wc -l) ==="
          echo "=== meta-rule file count: $(find meta-rule -type f | wc -l) ==="
          ls -R publish

      #
      # 7.5. Create ZIP archives
      #
      - name: Create ZIP archives
        run: |
          echo "=== Creating ZIP archives ==="
          mkdir -p release-assets
          
          # Sing-box rules (full version)
          echo "=== Zipping sing-box rules (full version) ==="
          cd sing-rule
          if ls *.srs 1> /dev/null 2>&1; then
            zip ../release-assets/sing-rules-srs.zip *.srs
            echo "Created sing-rules-srs.zip"
          fi
          if ls *.json 1> /dev/null 2>&1; then
            zip ../release-assets/sing-rules-json.zip *.json
            echo "Created sing-rules-json.zip"
          fi
          cd ..
          
          # Sing-box lite rules (IP-CIDR + DOMAIN only)
          echo "=== Zipping sing-box lite rules ==="
          cd sing-rule-lite
          
          # Check and package SRS files if they exist
          if ls *.srs 1> /dev/null 2>&1; then
            zip ../release-assets/sing-rules-lite-srs.zip *.srs
            echo "✅ Created sing-rules-lite-srs.zip (lite binary rules)"
          else
            echo "⚠️  No SRS files found - skipping lite SRS package"
          fi
          
          # Always package JSON files (should always exist)
          if ls *.json 1> /dev/null 2>&1; then
            zip ../release-assets/sing-rules-lite-json.zip *.json
            echo "✅ Created sing-rules-lite-json.zip (lite JSON rules)"
          else
            echo "❌ CRITICAL: No JSON files found in lite directory!"
          fi
          cd ..
          
          # Meta rules
          echo "=== Zipping meta rules ==="
          cd meta-rule
          if ls *.list 1> /dev/null 2>&1; then
            zip ../release-assets/meta-rules-list.zip *.list
            echo "Created meta-rules-list.zip"
          fi
          if ls *.yaml 1> /dev/null 2>&1; then
            zip ../release-assets/meta-rules-yaml.zip *.yaml
            echo "Created meta-rules-yaml.zip"
          fi
          cd ..
          
          echo "=== Release assets created ==="
          ls -al release-assets/

      #
      # 8. Create GitHub Release
      #
      - name: Create GitHub Release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: v${{ env.TAG_NAME }}
          name: Release ${{ env.BUILDTIME }}
          body: |
            ## 📦 Rule Packages
            
            ### Sing-box Rules (Complete Version)
            - `sing-rules-srs.zip` - Sing-box binary rule files (.srs) - **Complete rules**
            - `sing-rules-json.zip` - Sing-box JSON rule files (.json) - **Complete rules**
            
            ### Sing-box Lite Rules ⚡ (Ultra Performance)
            - `sing-rules-lite-srs.zip` - **🔥 Lite Binary** (.srs) - **IP-CIDR + DOMAIN only** - ⚡ **FASTEST**
            - `sing-rules-lite-json.zip` - **Lite JSON** (.json) - **IP-CIDR + DOMAIN only** - 📖 Human readable
            
            > 🚀 **Lite Rules**: Optimized for speed! Contains only the fastest rule types (IP-CIDR and DOMAIN matching), significantly reducing memory usage and matching latency.
            > 
            > 🔥 **SRS Format Recommended**: Binary format provides the best performance:
            > - ⚡ **Fastest loading** (~90% faster than JSON)
            > - 💾 **Smallest size** (~40% smaller than JSON) 
            > - 🚀 **Optimal for routers** and resource-constrained devices
            > 
            > 📁 **Directory**: `/sing-rule-lite/` (same filenames as complete rules, but filtered content)
            
            ### Meta Rules
            - `meta-rules-list.zip` - Meta list rule files (.list)
            - `meta-rules-yaml.zip` - Meta YAML rule files (.yaml)
            
            ### Build Information
            - Build Time: ${{ env.BUILDTIME }} (Asia/Shanghai)
            - Workflow Run: [${{ github.run_number }}](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})
            
            ### Performance Comparison
            | Rule Type | Complete Rules | Lite Rules |
            |-----------|----------------|------------|
            | Rule Types | All (DOMAIN, DOMAIN-SUFFIX, DOMAIN-KEYWORD, IP-CIDR, PROCESS-NAME) | IP-CIDR + DOMAIN only |
            | Memory Usage | Higher | 60-80% less |
            | Matching Speed | Standard | 3-5x faster |
            | Best For | Complete coverage | Performance-critical scenarios |
            
            ### Data Sources
            - Rules from [blackmatrix7/ios_rule_script](https://github.com/blackmatrix7/ios_rule_script)
            - Converter by [MetaCubeX/meta-rules-converter](https://github.com/MetaCubeX/meta-rules-converter)
          files: |
            release-assets/*
          fail_on_unmatched_files: false
          generate_release_notes: false

      #
      # 8.5. Also push to 'release' branch for backward compatibility
      #
      - name: Push to release branch
        run: |
          echo "=== Pushing to branch 'release' for backward compatibility ==="
          cd publish
          git init
          git config user.name "github-actions[bot]"
          git config user.email "idontknow+github-actions[bot]@users.noreply.github.com"
          git checkout -b release
          git add .
          git commit -m "Assets from ${{ env.BUILDTIME }} (tag: v${{ env.TAG_NAME }})"
          git remote add origin "https://${{ github.actor }}:${{ secrets.GITHUB_TOKEN }}@github.com/${{ github.repository }}"
          git push -f -u origin release

      #
      # 9. Purge jsdelivr CDN (optional)
      #
      - name: Purge jsdelivr CDN
        run: |
          echo "=== Purging jsDelivr cache for files in ./publish/ ==="
          for file in $(find publish -type f); do
            filename=$(basename "$file")
            echo "Purging $filename..."
            curl -i "https://purge.jsdelivr.net/gh/${{ github.repository }}@release/${filename}"
          done

      #
      # 10. Victory! (optional)
      #
      - name: Done
        run: echo "All steps completed!"
