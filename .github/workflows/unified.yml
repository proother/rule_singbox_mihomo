# Unified workflow placeholder

name: Unified Rules Builder (Parallel Jobs)

on:
  push:
    branches:
      - main
  workflow_dispatch:
  schedule:
    - cron: '0 12 * * *'  # åŒ—äº¬æ—¶é—´ 20:00

permissions:
  contents: write

env:
  GOAMD64: v3
  BUILDTIME: ${{ github.run_id }}
  TAG_NAME: ${{ github.run_id }}

jobs:
  # Job 1: Generate Sing-box Rules (Parallel)
  sing-box-rules:
    runs-on: ubuntu-latest
    steps:
      - name: Set variables
        run: |
          echo "GOAMD64=v3" >> $GITHUB_ENV
          echo "BUILDTIME=$(TZ=Asia/Shanghai date +'%Y-%m-%d %H:%M')" >> $GITHUB_ENV
          echo "TAG_NAME=$(TZ=Asia/Shanghai date +'%Y%m%d-%H%M')" >> $GITHUB_ENV

      - name: Checkout current repository
        uses: actions/checkout@v4
        with:
          path: current-repo

      - name: Setup sing-box
        env:
          SING_BOX_DEB_URL: "https://github.com/SagerNet/sing-box/releases/download/v1.10.0-beta.5/sing-box_1.10.0-beta.5_linux_amd64.deb"
        run: |
          set -Eeuo pipefail
          wget -O sing-box.deb $SING_BOX_DEB_URL
          sudo dpkg -i sing-box.deb
          rm sing-box.deb

      - name: Clone blackmatrix7 repository
        run: |
          echo "ðŸ“¥ Cloning blackmatrix7/ios_rule_script repository..."
          git clone https://github.com/blackmatrix7/ios_rule_script.git temp-ios-rule-script
          echo "âœ… Repository cloned successfully"

      - name: Copy optimal integration script
        run: |
          # Copy our optimal integration script
          cp current-repo/optimal_integration_fixed_v9.py ./
          cp current-repo/requirements.txt ./
          
          # No need to modify paths - they are already correct in the script
          # Source directory: temp-ios-rule-script/rule/Clash (original rules)
          # Target directory: sing-rule (generated sing-box rules)

      - name: Setup Python environment
        run: |
          set -Eeuo pipefail
          python3 -m venv venv
          source venv/bin/activate
          pip3 install -r requirements.txt
          # Install additional dependencies
          pip3 install PyYAML

      - name: Generate sing-box rules using optimal integration
        run: |
          echo "ðŸŽ¯ GENERATING SING-BOX RULES (Optimal Integration Method)"
          set -Eeuo pipefail
          source venv/bin/activate
          python3 optimal_integration_fixed_v9.py
          
          echo "ðŸ“Š Generated files:"
          echo "   JSON files: $(find sing-rule -name "*.json" | wc -l)"

      - name: Compile sing-box rules to SRS format
        run: |
          echo "ðŸ”„ Compiling sing-box rules to SRS format..."
          cd sing-rule
          
          # Compile all JSON files to SRS format
          for json_file in *.json; do
            if [[ -f "$json_file" ]]; then
              filename=$(basename "$json_file" .json)
              echo "   Compiling: $filename"
              sing-box rule-set compile --output "${filename}.srs" "$json_file"
            fi
          done
          
          cd ..
          
          echo "ðŸ“Š Compiled files:"
          echo "   SRS files: $(find sing-rule -name "*.srs" | wc -l)"

      - name: Create lite rules
        run: |
          echo "ðŸ”§ Creating Lite rules (IP-CIDR + DOMAIN + DOMAIN_KEYWORD, exclude PROCESS_NAME)..."
          mkdir -p sing-rule-lite
          sudo apt-get update && sudo apt-get install -y jq
          
          # Copy complete rules and filter
          for json_file in sing-rule/*.json; do
            if [[ -f "$json_file" ]]; then
              filename=$(basename "$json_file" .json)
              echo "   Processing: $filename"
              
              # Extract rules containing ip_cidr, domain, domain_suffix, and domain_keyword (exclude process_name only)
              jq '{version: .version, rules: [.rules[] | with_entries(select(.key == "ip_cidr" or .key == "domain" or .key == "domain_suffix" or .key == "domain_keyword")) | select(. != {})]}' "$json_file" > "sing-rule-lite/${filename}.json"
              
              # Check if there are valid rules
              rule_count=$(jq '[.rules[]? | length] | add // 0' "sing-rule-lite/${filename}.json")
              if [[ "$rule_count" -eq 0 ]]; then
                echo "   âŒ Removed empty: $filename (0 rules)"
                rm "sing-rule-lite/${filename}.json"
              else
                echo "   âœ… Created: $filename ($rule_count rules)"
                
                # If corresponding SRS file exists, also copy one for subsequent processing
                if [[ -f "sing-rule/${filename}.srs" ]]; then
                  cp "sing-rule/${filename}.srs" "sing-rule-lite/${filename}_temp.srs"
                fi
              fi
            fi
          done
          
          # Recompile SRS for lite version
          cd sing-rule-lite
          for json_file in *.json; do
            if [[ -f "$json_file" ]]; then
              filename=$(basename "$json_file" .json)
              sing-box rule-set compile --output "${filename}.srs" "$json_file"
              echo "   âœ… Compiled lite SRS: $filename"
            fi
          done
          
          # Clean up temporary files
          rm -f *_temp.srs
          cd ..
          
          echo "ðŸŽ‰ Lite rules creation complete:"
          echo "   ðŸ“„ Lite JSON files: $(find sing-rule-lite -name "*.json" | wc -l)"
          echo "   ðŸ“„ Lite SRS files: $(find sing-rule-lite -name "*.srs" | wc -l)"

      - name: Check if sing-box artifacts exist
        id: check-artifacts
        run: |
          echo "ðŸ” Checking if sing-box artifacts exist..."
          if [ -d "sing-rule" ] && [ "$(find sing-rule -name '*.json' -o -name '*.srs' | wc -l)" -gt 0 ]; then
            echo "âœ… sing-rule directory has files"
            echo "has_sing_rule=true" >> $GITHUB_OUTPUT
          else
            echo "âŒ sing-rule directory is empty or missing"
            echo "has_sing_rule=false" >> $GITHUB_OUTPUT
          fi
          
          if [ -d "sing-rule-lite" ] && [ "$(find sing-rule-lite -name '*.json' -o -name '*.srs' | wc -l)" -gt 0 ]; then
            echo "âœ… sing-rule-lite directory has files"
            echo "has_sing_rule_lite=true" >> $GITHUB_OUTPUT
          else
            echo "âŒ sing-rule-lite directory is empty or missing"
            echo "has_sing_rule_lite=false" >> $GITHUB_OUTPUT
          fi

      - name: Upload sing-box artifacts
        if: steps.check-artifacts.outputs.has_sing_rule == 'true' || steps.check-artifacts.outputs.has_sing_rule_lite == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: sing-box-rules
          path: |
            sing-rule/
            sing-rule-lite/

  # Job 2: Generate Mihomo Rules (Official MetaCubeX Method)
  mihomo-rules:
    runs-on: ubuntu-latest
    steps:
      - name: Set variables
        run: |
          echo "GOAMD64=v3" >> $GITHUB_ENV
          echo "BUILDTIME=$(TZ=Asia/Shanghai date +'%Y-%m-%d %H:%M')" >> $GITHUB_ENV
          echo "TAG_NAME=$(TZ=Asia/Shanghai date +'%Y%m%d-%H%M')" >> $GITHUB_ENV
          echo "CHINA_DOMAINS_URL=https://raw.githubusercontent.com/blackmatrix7/ios_rule_script/master/rule/Clash/ChinaMax/ChinaMax_Domain.txt" >> $GITHUB_ENV
          echo "GOOGLE_DOMAINS_URL=https://raw.githubusercontent.com/felixonmars/dnsmasq-china-list/master/google.china.conf" >> $GITHUB_ENV
          echo "APPLE_DOMAINS_URL=https://raw.githubusercontent.com/felixonmars/dnsmasq-china-list/master/apple.china.conf" >> $GITHUB_ENV
          echo "CUSTOM_PROXY=https://raw.githubusercontent.com/Loyalsoldier/domain-list-custom/release/geolocation-!cn.txt" >> $GITHUB_ENV
        shell: bash

      - name: Checkout MetaCubeX/meta-rules-dat (Official)
        uses: actions/checkout@v4
        with:
          repository: MetaCubeX/meta-rules-dat

      - name: Checkout Loyalsoldier/domain-list-custom
        uses: actions/checkout@v4
        with:
          repository: Loyalsoldier/domain-list-custom
          path: custom

      - name: Checkout v2fly/domain-list-community
        uses: actions/checkout@v4
        with:
          repository: v2fly/domain-list-community
          path: community

      - name: Checkout MetaCubeX/meta-rules-converter
        uses: actions/checkout@v4
        with:
          repository: MetaCubeX/meta-rules-converter
          path: convert

      - name: Checkout cokebar/gfwlist2dnsmasq
        uses: actions/checkout@v4
        with:
          repository: cokebar/gfwlist2dnsmasq
          path: gfwlist2dnsmasq

      - name: Setup Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.22'

      - name: Generate GFWList domains
        run: |
          echo "ðŸ›¡ï¸ GENERATING MIHOMO RULES (Official MetaCubeX Method)"
          cd gfwlist2dnsmasq || exit 1
          chmod +x ./gfwlist2dnsmasq.sh
          ./gfwlist2dnsmasq.sh -l -o ./temp-gfwlist.txt

      - name: Get and add direct domains into temp-direct.txt file
        run: |
          curl -sSL ${CHINA_DOMAINS_URL} | sed '/^\s*#/d' | sed '/^[^\.]/ s/^/full:/' |  sed 's/^\.\([^.]*\)/\1/' > temp-direct.txt 

      - name: Get and add proxy domains into temp-proxy.txt file
        run: |
          cat ./gfwlist2dnsmasq/temp-gfwlist.txt | perl -ne '/^((?=^.{3,255})[a-zA-Z0-9][-_a-zA-Z0-9]{0,62}(\.[a-zA-Z0-9][-_a-zA-Z0-9]{0,62})+)/ && print "$1\n"' > temp-proxy.txt
          curl -sSL $GOOGLE_DOMAINS_URL | perl -ne '/^server=\/([^\/]+)\// && print "$1\n"' >> temp-proxy.txt
          curl -sSL $APPLE_DOMAINS_URL | perl -ne '/^server=\/([^\/]+)\// && print "$1\n"' >> temp-proxy.txt
          curl -sSL ${CUSTOM_PROXY} | grep -Ev ":@cn" | perl -ne '/^(domain):([^:]+)(\n$|:@.+)/ && print "$2\n"' >> temp-proxy.txt

      - name: Reserve `full`, `regexp` and `keyword` type of rules from custom lists to "reserve" files
        run: |
          curl -sSL ${CUSTOM_PROXY} | grep -Ev ":@cn" | perl -ne '/^((full|regexp|keyword):[^:]+)(\n$|:@.+)/ && print "$1\n"' | sort --ignore-case -u > proxy-reserve.txt
          
      - name: Add proxy, direct and reject domains from "hidden" branch to appropriate temp files
        run: |
          cat ./resouces/proxy.txt >> temp-proxy.txt
          cat ./resouces/direct.txt >> temp-direct.txt

      - name: Sort and generate redundant lists
        run: |
          cat temp-proxy.txt | sort --ignore-case -u > proxy-list-with-redundant
          cat temp-direct.txt | sort --ignore-case -u > direct-list-with-redundant

      - name: Remove redundant domains (Official Method)
        run: |
          echo "ðŸ”§ Using Official MetaCubeX redundancy removal..."
          chmod +x ./resouces/*.py
          python ./resouces/findRedundantDomain.py ./direct-list-with-redundant ./direct-list-deleted-unsort
          python ./resouces/findRedundantDomain.py ./proxy-list-with-redundant ./proxy-list-deleted-unsort
          [ ! -f "direct-list-deleted-unsort" ] && touch direct-list-deleted-unsort
          [ ! -f "proxy-list-deleted-unsort" ] && touch proxy-list-deleted-unsort
          sort ./direct-list-deleted-unsort > ./direct-list-deleted-sort
          sort ./proxy-list-deleted-unsort > ./proxy-list-deleted-sort
          python ./resouces/removeFrom.py -remove ./direct-list-deleted-sort -from ./direct-list-with-redundant -out direct-list-without-redundant
          python ./resouces/removeFrom.py -remove ./proxy-list-deleted-sort -from ./proxy-list-with-redundant -out proxy-list-without-redundant

      - name: Remove domains from "need-to-remove" lists in "hidden" branch
        run: |
          python ./resouces/removeFrom.py -remove ./resouces/direct-need-to-remove.txt -from ./direct-list-without-redundant -out ./temp-cn.txt
          python ./resouces/removeFrom.py -remove ./resouces/proxy-need-to-remove.txt -from ./proxy-list-without-redundant -out ./temp-geolocation-\!cn.txt

      - name: Remove domains end with ".cn" in "temp-geolocation-!cn.txt" and write lists to data directory
        run: |
          cat temp-cn.txt | grep -v google | grep -v manhua | grep -v ooklaserver | grep -v "acg.rip" | sort --ignore-case -u | perl -ne '/^((?=^.{1,255})[a-zA-Z0-9][-_a-zA-Z0-9]{0,62}(\.[a-zA-Z0-9][-_a-zA-Z0-9]{0,62})*)/ && print "$1\n"' > ./community/data/cn
          cat temp-cn.txt | sort --ignore-case -u | perl -ne 'print if not /^((?=^.{3,255})[a-zA-Z0-9][-_a-zA-Z0-9]{0,62}(\.[a-zA-Z0-9][-_a-zA-Z0-9]{0,62})+)/' > direct-tld-list.txt
          cat temp-geolocation-\!cn.txt | sort --ignore-case -u | perl -ne '/^((?=^.{1,255})[a-zA-Z0-9][-_a-zA-Z0-9]{0,62}(\.[a-zA-Z0-9][-_a-zA-Z0-9]{0,62})*)/ && print "$1\n"' | perl -ne 'print if not /\.cn$/' > ./community/data/geolocation-\!cn
          cat temp-geolocation-\!cn.txt | sort --ignore-case -u | perl -ne 'print if not /^((?=^.{3,255})[a-zA-Z0-9][-_a-zA-Z0-9]{0,62}(\.[a-zA-Z0-9][-_a-zA-Z0-9]{0,62})+)/' > proxy-tld-list.txt

      - name: Add `full`, `regexp` and `keyword` type of rules back into "cn", and "geolocation-!cn" list
        run: |
          [ -f "direct-reserve.txt" ] && cat direct-reserve.txt >> ./community/data/cn
          [ -f "proxy-reserve.txt" ] && cat proxy-reserve.txt >> ./community/data/geolocation-\!cn
          cp ./community/data/cn direct-list.txt
          cp ./community/data/geolocation-\!cn proxy-list.txt

      - name: Setup Go dependencies for custom
        run: |
          cd custom || exit 1
          go mod download
          go mod tidy

      - name: Build geosite.dat file
        run: |
          cd custom || exit 1
          echo ipleak.net >> ../community/data/geolocation-\!cn && echo browserleaks.org >> ../community/data/geolocation-\!cn
          go run ./ --datapath=../community/data

      - name: Setup Go dependencies for convert
        run: |
          cd convert || exit 1
          go mod download
          go mod tidy

      - name: Convert geo to meta-rule-set
        env:
          NO_SKIP: true
        run: |
          mkdir -p meta-rule/geo/geosite && mkdir -p meta-rule/geo/geoip
          cd convert
          go run ./ geosite -f ../custom/publish/geosite.dat -o ../meta-rule/geo/geosite
          
          echo "âœ… Meta rules generated:"
          echo "   YAML files: $(find ../meta-rule -name "*.yaml" | wc -l)"
          echo "   LIST files: $(find ../meta-rule -name "*.list" | wc -l)"
          echo "   MRS files: $(find ../meta-rule -name "*.mrs" | wc -l)"

      - name: Check if mihomo artifacts exist
        id: check-mihomo-artifacts
        run: |
          echo "ðŸ” Checking if mihomo artifacts exist..."
          if [ -d "meta-rule" ] && [ "$(find meta-rule -name '*.yaml' -o -name '*.list' -o -name '*.mrs' | wc -l)" -gt 0 ]; then
            echo "âœ… meta-rule directory has files"
            echo "has_mihomo_artifacts=true" >> $GITHUB_OUTPUT
          else
            echo "âŒ meta-rule directory is empty or missing"
            echo "has_mihomo_artifacts=false" >> $GITHUB_OUTPUT
          fi

      - name: Upload mihomo artifacts
        if: steps.check-mihomo-artifacts.outputs.has_mihomo_artifacts == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: mihomo-rules
          path: meta-rule/

  # Job 3: Generate GeoIP Rules (Parallel)
  geoip-rules:
    runs-on: ubuntu-latest
    steps:
      - name: Set variables
        run: |
          echo "GOAMD64=v3" >> $GITHUB_ENV
          echo "BUILDTIME=$(TZ=Asia/Shanghai date +'%Y-%m-%d %H:%M')" >> $GITHUB_ENV
          echo "TAG_NAME=$(TZ=Asia/Shanghai date +'%Y%m%d-%H%M')" >> $GITHUB_ENV

      - name: Checkout current repository
        uses: actions/checkout@v4

      - name: Setup Go
        uses: actions/setup-go@v5
        with:
          go-version: ^1.22

      - name: Install dependencies
        run: |
          echo "ðŸ“¦ Installing GeoIP generator dependencies..."
          go mod download
          go mod tidy

      - name: Setup Go with cache
        uses: actions/setup-go@v5
        with:
          go-version: ^1.22
          cache: true

      - name: Build geoip rule sets
        id: build
        run: |
          echo "ðŸŒ GENERATING GEOIP RULE SETS"
          go run -v geoip_generator.go
          
          echo "ðŸ“Š Generated GeoIP files:"
          if [ -d "release/sing-geoip" ]; then
            echo "   SRS files: $(find release/sing-geoip -name "*.srs" | wc -l)"
            ls -la release/sing-geoip/*.srs | head -10
            echo "   ..."
          else
            echo "   âŒ No GeoIP files generated"
          fi
        env:
          FIXED_RELEASE: ${{ github.event.inputs.tag }}
          ACCESS_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Upload geoip artifacts
        uses: actions/upload-artifact@v4
        with:
          name: geoip-rules
          path: release/sing-geoip/

  # Job 4: Publish (Sequential - waits for all three parallel jobs)
  publish:
    runs-on: ubuntu-latest
    needs: [sing-box-rules, mihomo-rules, geoip-rules]
    steps:
      - name: Set variables
        run: |
          echo "GOAMD64=v3" >> $GITHUB_ENV
          echo "BUILDTIME=$(TZ=Asia/Shanghai date +'%Y-%m-%d %H:%M')" >> $GITHUB_ENV
          echo "TAG_NAME=$(TZ=Asia/Shanghai date +'%Y%m%d-%H%M')" >> $GITHUB_ENV

      - name: Download sing-box artifacts
        uses: actions/download-artifact@v4
        with:
          name: sing-box-rules
          path: ./
        continue-on-error: true

      - name: Download mihomo artifacts
        uses: actions/download-artifact@v4
        with:
          name: mihomo-rules
          path: ./
        continue-on-error: true

      - name: Download geoip artifacts
        uses: actions/download-artifact@v4
        with:
          name: geoip-rules
          path: ./release/sing-geoip
        continue-on-error: true

      - name: Prepare publish artifacts
        run: |
          echo "ðŸ“¦ PREPARING UNIFIED PUBLISH"
          mkdir -p publish
          
          # Copy sing-box rules if they exist
          if [ -d "sing-rule" ] && [ "$(find sing-rule -name '*.json' -o -name '*.srs' | wc -l)" -gt 0 ]; then
            cp -r sing-rule publish/sing-rule
            echo "âœ… Copied sing-rule: $(find publish/sing-rule -name '*.json' -o -name '*.srs' | wc -l) files"
          else
            echo "âš ï¸ No sing-rule files found"
          fi
          
          if [ -d "sing-rule-lite" ] && [ "$(find sing-rule-lite -name '*.json' -o -name '*.srs' | wc -l)" -gt 0 ]; then
            cp -r sing-rule-lite publish/sing-rule-lite
            echo "âœ… Copied sing-rule-lite: $(find publish/sing-rule-lite -name '*.json' -o -name '*.srs' | wc -l) files"
          else
            echo "âš ï¸ No sing-rule-lite files found"
          fi
          
          # Copy GeoIP rules
          if [ -d "release/sing-geoip" ]; then
            cp -r release/sing-geoip publish/sing-geoip
            echo "âœ… Copied GeoIP rules: $(find publish/sing-geoip -name "*.srs" | wc -l) files"
          else
            echo "âš ï¸ No GeoIP rules found"
          fi
          
          echo "ðŸ” Debug: Checking directory structure after artifact download..."
          echo "ðŸ“‚ Root directory contents:"
          ls -la
          echo ""
          
          echo "ðŸ“‚ Looking for possible mihomo artifact locations:"
          echo "   Checking ./meta-rule:"
          ls -la meta-rule/ 2>/dev/null || echo "   âŒ ./meta-rule not found"
          echo ""
          echo "   Checking ./geo:"
          ls -la geo/ 2>/dev/null || echo "   âŒ ./geo not found"
          echo ""
          echo "   Checking ./geo/geosite:"
          ls -la geo/geosite/ 2>/dev/null | head -10 || echo "   âŒ ./geo/geosite not found"
          
          # Check meta-rule directory structure and adapt (artifacts may be extracted to different locations)
          META_RULE_PATH=""
          
          # Check possible paths
          if [ -d "meta-rule/geo/geosite" ]; then
            META_RULE_PATH="meta-rule/geo/geosite"
            echo "âœ… Found rules at: meta-rule/geo/geosite"
          elif [ -d "geo/geosite" ]; then
            META_RULE_PATH="geo/geosite"
            echo "âœ… Found rules at: geo/geosite (artifact extracted without meta-rule prefix)"
          elif [ -d "geosite" ]; then
            META_RULE_PATH="geosite"
            echo "âœ… Found rules at: geosite (flat structure)"
          elif [ -d "meta-rule" ] && [ ! -d "meta-rule/geo" ]; then
            META_RULE_PATH="meta-rule"
            echo "âœ… Found rules at: meta-rule (already flat)"
          fi
          
          if [ -n "$META_RULE_PATH" ]; then
            echo "ðŸ”§ Processing rules from: $META_RULE_PATH"
            mkdir -p publish/meta-rule
            
            echo "ðŸ” Searching for rule files..."
            echo "   YAML files: $(find "$META_RULE_PATH" -name "*.yaml" -type f | wc -l)"
            echo "   LIST files: $(find "$META_RULE_PATH" -name "*.list" -type f | wc -l)"
            echo "   MRS files: $(find "$META_RULE_PATH" -name "*.mrs" -type f | wc -l)"
            
            # Copy all files to flat structure
            echo "ðŸ”§ Copying all rule files..."
            cp "$META_RULE_PATH"/*.yaml publish/meta-rule/ 2>/dev/null || true
            cp "$META_RULE_PATH"/*.list publish/meta-rule/ 2>/dev/null || true
            cp "$META_RULE_PATH"/*.mrs publish/meta-rule/ 2>/dev/null || true
            
            echo "ðŸ” Final meta-rule directory contents:"
            ls -la publish/meta-rule/ | head -20
            echo "ðŸ“Š Meta-rule files count:"
            echo "  YAML: $(find publish/meta-rule -name "*.yaml" | wc -l)"
            echo "  LIST: $(find publish/meta-rule -name "*.list" | wc -l)"
            echo "  MRS: $(find publish/meta-rule -name "*.mrs" | wc -l)"
          else
            echo "âŒ No valid meta-rule structure found!"
            echo "ðŸ“‚ Available directories:"
            ls -la
            echo "ðŸš¨ Creating empty meta-rule to prevent total failure..."
            mkdir -p publish/meta-rule
            echo "# Empty meta-rule directory" > publish/meta-rule/README.md
          fi
          
          echo "=== Artifact Summary ==="
          echo "Sing-box rules: $(find publish/sing-rule -type f | wc -l) files"
          echo "Sing-box lite: $(find publish/sing-rule-lite -type f | wc -l) files"
          echo "Mihomo rules: $(find publish/meta-rule -type f | wc -l) files"
          echo "GeoIP rules: $(find publish/sing-geoip -type f 2>/dev/null | wc -l) files"

      - name: Create ZIP archives
        run: |
          mkdir -p release-assets
          echo "ðŸ“¦ Creating ZIP packages"
          
          echo "ðŸ” Debug: Checking publish directory structure before ZIP..."
          echo "ðŸ“‚ publish/ contents:"
          ls -la publish/
          echo "ðŸ“‚ publish/meta-rule contents:"
          ls -la publish/meta-rule/ | head -20 || echo "âŒ meta-rule directory not found or empty"
          
          # Sing-box packages
          if [ -d "publish/sing-rule" ]; then
            cd publish/sing-rule
            if ls *.srs 1> /dev/null 2>&1; then
              zip -r ../../release-assets/sing-rules-srs.zip *.srs
              echo "âœ… sing-rules-srs.zip ($(ls *.srs | wc -l) files)"
            else
              echo "âš ï¸ No .srs files found in sing-rule"
            fi
            if ls *.json 1> /dev/null 2>&1; then
              zip -r ../../release-assets/sing-rules-json.zip *.json
              echo "âœ… sing-rules-json.zip ($(ls *.json | wc -l) files)"
            else
              echo "âš ï¸ No .json files found in sing-rule"
            fi
            cd ../..
          else
            echo "âš ï¸ sing-rule directory not found"
          fi
          
          if [ -d "publish/sing-rule-lite" ]; then
            cd publish/sing-rule-lite
            if ls *.srs 1> /dev/null 2>&1; then
              zip -r ../../release-assets/sing-rules-lite-srs.zip *.srs
              echo "âœ… sing-rules-lite-srs.zip ($(ls *.srs | wc -l) files)"
            else
              echo "âš ï¸ No .srs files found in sing-rule-lite"
            fi
            if ls *.json 1> /dev/null 2>&1; then
              zip -r ../../release-assets/sing-rules-lite-json.zip *.json
              echo "âœ… sing-rules-lite-json.zip ($(ls *.json | wc -l) files)"
            else
              echo "âš ï¸ No .json files found in sing-rule-lite"
            fi
            cd ../..
          else
            echo "âš ï¸ sing-rule-lite directory not found"
          fi
          
          # Mihomo packages  
          if [ -d "publish/meta-rule" ]; then
            cd publish/meta-rule
            echo "ðŸ” Current directory: $(pwd)"
            echo "ðŸ“‚ Files in meta-rule:"
            ls -la | head -20
            
            if ls *.yaml 1> /dev/null 2>&1; then
              zip -r ../../release-assets/meta-rules-yaml.zip *.yaml
              echo "âœ… meta-rules-yaml.zip ($(ls *.yaml | wc -l) files)"
            else
              echo "âš ï¸ No .yaml files found in meta-rule"
            fi
            if ls *.list 1> /dev/null 2>&1; then
              zip -r ../../release-assets/meta-rules-list.zip *.list
              echo "âœ… meta-rules-list.zip ($(ls *.list | wc -l) files)"
            else
              echo "âš ï¸ No .list files found in meta-rule"
            fi
            if ls *.mrs 1> /dev/null 2>&1; then
              zip -r ../../release-assets/meta-rules-mrs.zip *.mrs
              echo "âœ… meta-rules-mrs.zip ($(ls *.mrs | wc -l) files)"
            else
              echo "âš ï¸ No .mrs files found in meta-rule"
            fi
            cd ../..
          else
            echo "âš ï¸ meta-rule directory not found"
          fi
          
          # GeoIP packages
          if [ -d "publish/sing-geoip" ]; then
            cd publish/sing-geoip
            if ls *.srs 1> /dev/null 2>&1; then
              zip -r ../../release-assets/sing-box-geoip-srs.zip *.srs
              echo "âœ… sing-box-geoip-srs.zip ($(ls *.srs | wc -l) files)"
            else
              echo "âš ï¸ No .srs files found in sing-geoip"
            fi
            cd ../..
          else
            echo "âš ï¸ sing-geoip directory not found"
          fi
          
          echo "ðŸ“¦ Final release-assets contents:"
          ls -la release-assets/

      - name: Create Unified GitHub Release
        uses: softprops/action-gh-release@v2.3.2
        with:
          tag_name: v${{ env.TAG_NAME }}
          name: Release ${{ env.BUILDTIME }}
          body: |
            ## âš¡ å¹¶è¡Œæž„å»ºç‰ˆæœ¬ (Ultra Fast)
            
            ### ðŸŽ¯ Sing-box è§„åˆ™
            - `sing-rules-srs.zip` - å®Œæ•´ç‰ˆ (.srs äºŒè¿›åˆ¶ï¼Œä¾›ç”µè„‘ç‰ˆå†…æ ¸ä½¿ç”¨)
            - `sing-rules-json.zip` - å®Œæ•´ç‰ˆ (.json æºç ï¼Œä¾›ç”µè„‘ç‰ˆå†…æ ¸ä½¿ç”¨)
            - `sing-rules-lite-srs.zip` - ç²¾ç®€ç‰ˆ (.srs äºŒè¿›åˆ¶ï¼ŒæŽ’é™¤ PROCESS_NAMEï¼Œä¾›ç§»åŠ¨ç‰ˆå†…æ ¸ä½¿ç”¨)
            - `sing-rules-lite-json.zip` - ç²¾ç®€ç‰ˆ (.json æºç ï¼ŒæŽ’é™¤ PROCESS_NAMEï¼Œä¾›ç§»åŠ¨ç‰ˆå†…æ ¸ä½¿ç”¨)
            
            ### ðŸ›¡ï¸ Mihomo è§„åˆ™
            - `meta-rules-yaml.zip` - YAML æ ¼å¼ (é»˜è®¤)
            - `meta-rules-list.zip` - LIST æ ¼å¼ (çº¯æ–‡æœ¬ï¼ŒåŠ è½½æ›´å¿«)
            - `meta-rules-mrs.zip` - MRS æ ¼å¼ (äºŒè¿›åˆ¶ï¼Œæ€§èƒ½æœ€ä¼˜)
            
            ### ðŸŒ GeoIP è§„åˆ™
            - `sing-box-geoip-srs.zip` - æ‰€æœ‰å›½å®¶/åœ°åŒºçš„ IP åœ°å€æ®µ (.srs äºŒè¿›åˆ¶)
            - æ–‡ä»¶æ ¼å¼: `geoip-{å›½å®¶ä»£ç }.srs` (å¦‚ `geoip-cn.srs`)
            - åŒ…å« 200+ ä¸ªå›½å®¶/åœ°åŒºçš„ IP æ•°æ®
            
            ### âš¡ å¹¶è¡Œæž„å»ºä¼˜åŠ¿
            - ðŸš€ **3x æž„å»ºé€Ÿåº¦**: Sing-boxã€Mihomo å’Œ GeoIP å¹¶è¡Œç”Ÿæˆ
            - ðŸŽ¯ **èµ„æºéš”ç¦»**: æ¯ä¸ªJobç‹¬ç«‹è¿è¡Œï¼Œäº’ä¸å¹²æ‰°
            - ðŸ“Š **æ¸…æ™°æ—¥å¿—**: åˆ†Jobæ˜¾ç¤ºï¼Œé—®é¢˜å®šä½æ›´å®¹æ˜“
            - ðŸ”¥ **å®˜æ–¹ç®—æ³•**: å®Œå…¨ä½¿ç”¨MetaCubeXå®˜æ–¹ä»£ç å’Œç®—æ³•
            
            ### ðŸ“Š æ•°æ®æº
            - **Sing-box**: iOS rule script (~15k è§„åˆ™)
            - **Mihomo**: å¤šæºæ•´åˆ GFWList + China domains (~30k è§„åˆ™)
            - **GeoIP**: MaxMind GeoIP æ•°æ®åº“ (æ¯æœˆæ›´æ–°)
            
            ### ðŸ”— è®¿é—®æ–¹å¼
            - **å®Œæ•´è§„åˆ™**: `release` åˆ†æ”¯åŒ…å«æ‰€æœ‰è§„åˆ™æ–‡ä»¶
            - **GitHub Raw**: `https://raw.githubusercontent.com/proother/rule_singbox_mihomo/refs/heads/release/`
            - **jsDelivr CDN**: `https://cdn.jsdelivr.net/gh/proother/rule_singbox_mihomo@release/`
          files: |
            release-assets/*.zip

      - name: Push to release branch (Complete Rules)
        run: |
          echo "ðŸŒ³ PUSHING TO RELEASE BRANCH (Complete Rules)"
          cd publish && git init && git config --local user.name "github-actions[bot]" && git config --local user.email "41898282+github-actions[bot]@users.noreply.github.com"
          git checkout -b release && git add . && git commit -m "Released on ${{ env.BUILDTIME }}"
          git remote add origin "https://${{ github.actor }}:${{ secrets.GITHUB_TOKEN }}@github.com/${{ github.repository }}"
          git push -f -u origin release

      - name: Purge jsDelivr CDN
        run: |
          echo "ðŸš€ Purging jsDelivr CDN - This may take a while..."
          cd publish
          
          # Count files
          total_files=$(find . -name "*.srs" -o -name "*.json" -o -name "*.yaml" -o -name "*.list" -o -name "*.mrs" | wc -l)
          echo "ðŸ“Š Total files to purge: $total_files"
          
          # Batch purge CDN (100 files per batch)
          batch_size=100
          batch_num=0
          file_count=0
          
          find . -name "*.srs" -o -name "*.json" -o -name "*.yaml" -o -name "*.list" -o -name "*.mrs" | while IFS= read -r file; do
            file_path=$(echo "$file" | sed 's|^\./||')
            curl -s "https://purge.jsdelivr.net/gh/${{ github.repository }}@release/${file_path}" > /dev/null 2>&1 || true
            
            file_count=$((file_count + 1))
            
            # Show progress every 100 files
            if [ $((file_count % batch_size)) -eq 0 ]; then
              batch_num=$((batch_num + 1))
              echo "âœ… Batch $batch_num completed: $file_count/$total_files files purged"
            fi
          done
          
          echo "ðŸŽ‰ CDN purge completed! Total: $file_count files"
