# Unified workflow placeholder

name: Unified Rules Builder (Parallel Jobs)

on:
  push:
    branches:
      - main
  workflow_dispatch:
  schedule:
    - cron: '0 12 * * *'

permissions:
  contents: write

env:
  GOAMD64: v3
  BUILDTIME: ${{ github.run_id }}
  TAG_NAME: ${{ github.run_id }}

jobs:
  # Job 1: Generate Sing-box Rules (Parallel)
  sing-box-rules:
    runs-on: ubuntu-latest
    steps:
      - name: Set variables
        run: |
          echo "GOAMD64=v3" >> $GITHUB_ENV
          echo "BUILDTIME=$(TZ=Asia/Shanghai date +'%Y-%m-%d %H:%M')" >> $GITHUB_ENV
          echo "TAG_NAME=$(TZ=Asia/Shanghai date +'%Y%m%d-%H%M')" >> $GITHUB_ENV

      - name: Checkout blackmatrix7/ios_rule_script
        uses: actions/checkout@v4
        with:
          repository: blackmatrix7/ios_rule_script
          path: ios_rule_script

      - name: Checkout MetaCubeX/meta-rules-converter
        uses: actions/checkout@v4
        with:
          repository: MetaCubeX/meta-rules-converter
          path: converter

      - name: Setup Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.22'

      - name: Prepare data source
        run: |
          echo "ğŸ¯ GENERATING SING-BOX RULES"
          echo "ğŸ“ Scanning iOS rule script directories..."
          mkdir -p community/data_source
          total_dirs=0
          copied_files=0
          
          for dir in $(find ios_rule_script/rule/Clash -type d); do
            total_dirs=$((total_dirs + 1))
            if ls "$dir"/*_Classical.yaml 2>/dev/null; then
              classical_files=$(find "$dir" -type f -name '*_Classical.yaml' ! -name '*_No_Resolve.yaml')
              for file in $classical_files; do
                cp "$file" community/data_source/
                copied_files=$((copied_files + 1))
                echo "ğŸ“„ Copied: $(basename "$file")"
              done
            else
              dir_name=$(basename "$dir")
              target_file=$(find "$dir" -type f -name "${dir_name}.yaml" ! -name '*_No_Resolve.yaml' -print -quit)
              if [[ -n "$target_file" ]]; then
                cp "$target_file" community/data_source/
                copied_files=$((copied_files + 1))
                echo "ğŸ“„ Copied: $(basename "$target_file")"
              fi
            fi
          done
          
          echo "âœ… Data source preparation complete:"
          echo "   ğŸ“‚ Scanned directories: $total_dirs"
          echo "   ğŸ“„ Files copied: $copied_files"
          echo "   ğŸ“‹ Final count: $(ls community/data_source | wc -l) files"

      - name: Convert to sing rules
        run: |
          echo "ğŸ”„ Converting YAML rules to Sing-box format..."
          mkdir -p sing-rule
          cd converter && go build -o meta-converter .
          echo "âœ… Meta-converter built successfully"
          
          echo "ğŸ¯ Starting conversion process..."
          ./meta-converter clash -f ../community/data_source -o ../sing-rule -t sing-box
          
          echo "ğŸ“ Processing converted files..."
          cd ../sing-rule
          processed_count=0
          for dir in */; do
            dir_name=$(basename "$dir")
            if [[ -f "$dir/classical.json" && -f "$dir/classical.srs" ]]; then
              original_yaml=$(find ../community/data_source -type f -iname "${dir_name}.yaml" -print -quit)
              if [[ -n "$original_yaml" ]]; then
                original_name=$(basename "$original_yaml" .yaml)
                mv "$dir/classical.json" "${original_name}.json"
                mv "$dir/classical.srs" "${original_name}.srs"
                echo "âœ… Processed: ${original_name} (.json + .srs)"
              else
                mv "$dir/classical.json" "${dir_name}.json"
                mv "$dir/classical.srs" "${dir_name}.srs"
                echo "âœ… Processed: ${dir_name} (.json + .srs)"
              fi
              processed_count=$((processed_count + 1))
            fi
            rm -rf "$dir"
          done
          
          echo "ğŸ‰ Conversion complete:"
          echo "   ğŸ“„ Processed rules: $processed_count"
          echo "   ğŸ“Š Generated files: $(ls *.json *.srs 2>/dev/null | wc -l)"

      - name: Create lite rules with cleanup
        run: |
          echo "ğŸ”§ Creating Lite rules (IP-CIDR + DOMAIN only)..."
          mkdir -p sing-rule-lite
          sudo apt-get update && sudo apt-get install -y jq
          
          echo "ğŸ“ Step 1: Creating lite JSON rules..."
          lite_json_count=0
          for json_file in sing-rule/*.json; do
            if [[ -f "$json_file" ]]; then
              filename=$(basename "$json_file" .json)
              echo "   Processing: $filename"
              jq '{version: .version, rules: [.rules[] | with_entries(select(.key == "ip_cidr" or .key == "domain")) | select(keys | length > 0)]}' "$json_file" > "sing-rule-lite/${filename}.json"
              rule_count=$(jq '.rules | if . == null then 0 else length end' "sing-rule-lite/${filename}.json")
              if [[ "$rule_count" -eq 0 ]]; then
                echo "   âŒ Removed empty: $filename (0 rules)"
                rm "sing-rule-lite/${filename}.json"
              else
                echo "   âœ… Created: $filename ($rule_count rules)"
                lite_json_count=$((lite_json_count + 1))
              fi
            fi
          done
          
          echo "ğŸ“ Step 2: Preparing YAML sources for SRS conversion..."
          mkdir -p lite-yaml-source
          yaml_count=0
          for yaml_file in community/data_source/*.yaml; do
            if [[ -f "$yaml_file" ]]; then
              filename=$(basename "$yaml_file" .yaml)
              {
                echo "payload:"
                grep -E "^\s*-\s*DOMAIN," "$yaml_file" | sed 's/^[[:space:]]*/  /' || true
                grep -E "^\s*-\s*IP-CIDR," "$yaml_file" | sed 's/^[[:space:]]*/  /' || true
              } > "lite-yaml-source/${filename}.yaml"
              rule_count=$(grep -c "^\s*-\s*" "lite-yaml-source/${filename}.yaml" 2>/dev/null || echo "0")
              if [[ "$rule_count" -eq 0 ]]; then
                echo "payload:" > "lite-yaml-source/${filename}.yaml"
              fi
              yaml_count=$((yaml_count + 1))
            fi
          done
          
          echo "ğŸ“ Step 3: Converting lite YAML to SRS..."
          cd converter
          if ./meta-converter clash -f ../lite-yaml-source -o ../sing-rule-lite-converted -t sing-box 2>&1; then
            echo "âœ… SRS conversion successful"
            cd ../sing-rule-lite-converted
            srs_count=0
            for dir in */; do
              if [[ -d "$dir" ]]; then
                dir_name=$(basename "$dir")
                for lite_json in ../sing-rule-lite/*.json; do
                  if [[ -f "$lite_json" ]]; then
                    lite_basename=$(basename "$lite_json" .json)
                    if [[ "${lite_basename,,}" == "${dir_name,,}" ]]; then
                      original_basename=$(basename "$lite_json" .json)
                      if [[ -f "$dir/classical.json" && -f "$dir/classical.srs" ]]; then
                        mv "$dir/classical.json" "../sing-rule-lite/${original_basename}.json"
                        mv "$dir/classical.srs" "../sing-rule-lite/${original_basename}.srs"
                        echo "   âœ… SRS created: $original_basename"
                        srs_count=$((srs_count + 1))
                      elif [[ -f "$dir/classical.json" ]]; then
                        mv "$dir/classical.json" "../sing-rule-lite/${original_basename}.json"
                      fi
                      break
                    fi
                  fi
                done
              fi
            done
            cd ..
          else
            echo "âš ï¸ SRS conversion failed, continuing with JSON only"
          fi
          rm -rf lite-yaml-source sing-rule-lite-converted
          
          echo "ğŸ“ Step 4: Final cleanup - removing empty files..."
          cleaned_count=0
          for lite_file in sing-rule-lite/*.json; do
            if [[ -f "$lite_file" ]]; then
              rule_count=$(jq '.rules | if . == null then 0 else length end' "$lite_file" 2>/dev/null || echo "0")
              if [[ "$rule_count" -eq 0 ]]; then
                echo "   ğŸ—‘ï¸ Cleaned: $(basename "$lite_file") (empty)"
                rm "$lite_file"
                srs_file="${lite_file%.json}.srs"
                [[ -f "$srs_file" ]] && rm "$srs_file"
                cleaned_count=$((cleaned_count + 1))
              fi
            fi
          done
          
          echo "ğŸ‰ Lite rules creation complete:"
          echo "   ğŸ“„ Lite JSON files: $lite_json_count"
          echo "   ğŸ“„ YAML sources: $yaml_count"
          echo "   ğŸ“„ SRS files: $srs_count"
          echo "   ğŸ—‘ï¸ Cleaned empty: $cleaned_count"
          echo "   ğŸ“Š Final count: $(ls sing-rule-lite/*.json sing-rule-lite/*.srs 2>/dev/null | wc -l) files"

      - name: Upload sing-box artifacts
        uses: actions/upload-artifact@v4
        with:
          name: sing-box-rules
          path: |
            sing-rule/
            sing-rule-lite/

  # Job 2: Generate Mihomo Rules (Parallel) - Using Official Method
  mihomo-rules:
    runs-on: ubuntu-latest
    steps:
      - name: Set variables
        run: |
          echo "GOAMD64=v3" >> $GITHUB_ENV
          echo "BUILDTIME=$(TZ=Asia/Shanghai date +'%Y-%m-%d %H:%M')" >> $GITHUB_ENV
          echo "TAG_NAME=$(TZ=Asia/Shanghai date +'%Y%m%d-%H%M')" >> $GITHUB_ENV
          echo "CHINA_DOMAINS_URL=https://raw.githubusercontent.com/blackmatrix7/ios_rule_script/master/rule/Clash/ChinaMax/ChinaMax_Domain.txt" >> $GITHUB_ENV
          echo "GOOGLE_DOMAINS_URL=https://raw.githubusercontent.com/felixonmars/dnsmasq-china-list/master/google.china.conf" >> $GITHUB_ENV
          echo "APPLE_DOMAINS_URL=https://raw.githubusercontent.com/felixonmars/dnsmasq-china-list/master/apple.china.conf" >> $GITHUB_ENV
          echo "CUSTOM_PROXY=https://raw.githubusercontent.com/Loyalsoldier/domain-list-custom/release/geolocation-!cn.txt" >> $GITHUB_ENV

      - name: Checkout MetaCubeX/meta-rules-dat (for official scripts)
        uses: actions/checkout@v4
        with:
          repository: MetaCubeX/meta-rules-dat
          path: official

      - name: Checkout domain lists for mihomo
        uses: actions/checkout@v4
        with:
          repository: Loyalsoldier/domain-list-custom
          path: custom

      - name: Checkout v2fly/domain-list-community
        uses: actions/checkout@v4
        with:
          repository: v2fly/domain-list-community
          path: community

      - name: Checkout gfwlist tool
        uses: actions/checkout@v4
        with:
          repository: cokebar/gfwlist2dnsmasq
          path: gfwlist2dnsmasq

      - name: Checkout MetaCubeX/meta-rules-converter
        uses: actions/checkout@v4
        with:
          repository: MetaCubeX/meta-rules-converter
          path: converter

      - name: Setup Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.22'
          cache-dependency-path: ./custom/go.sum

      - name: Generate GFWList domains
        run: |
          echo "ğŸ›¡ï¸ GENERATING MIHOMO RULES (Official Method)"
          echo "ğŸ“¥ Step 1: Downloading GFWList..."
          cd gfwlist2dnsmasq && chmod +x ./gfwlist2dnsmasq.sh && ./gfwlist2dnsmasq.sh -l -o ./temp-gfwlist.txt
          gfw_count=$(wc -l < ./temp-gfwlist.txt)
          echo "âœ… GFWList downloaded: $gfw_count domains"

      - name: Get and add direct domains into temp-direct.txt file
        run: |
          echo "ğŸ“¥ Step 2: Downloading China domains..."
          curl -sSL ${CHINA_DOMAINS_URL} | sed '/^\s*#/d' | sed '/^[^\.]/ s/^/full:/' | sed 's/^\.\([^.]*\)/\1/' > temp-direct.txt
          china_count=$(wc -l < temp-direct.txt)
          echo "âœ… China domains downloaded: $china_count domains"

      - name: Get and add proxy domains into temp-proxy.txt file
        run: |
          echo "ğŸ“¥ Step 3: Collecting proxy domains..."
          cat ./gfwlist2dnsmasq/temp-gfwlist.txt | perl -ne '/^((?=^.{3,255})[a-zA-Z0-9][-_a-zA-Z0-9]{0,62}(\.[a-zA-Z0-9][-_a-zA-Z0-9]{0,62})+)/ && print "$1\n"' > temp-proxy.txt
          proxy_initial=$(wc -l < temp-proxy.txt)
          
          curl -sSL $GOOGLE_DOMAINS_URL | perl -ne '/^server=\/([^\/]+)\// && print "$1\n"' >> temp-proxy.txt
          proxy_google=$(wc -l < temp-proxy.txt)
          
          curl -sSL $APPLE_DOMAINS_URL | perl -ne '/^server=\/([^\/]+)\// && print "$1\n"' >> temp-proxy.txt
          proxy_apple=$(wc -l < temp-proxy.txt)
          
          curl -sSL ${CUSTOM_PROXY} | grep -Ev ":@cn" | perl -ne '/^(domain):([^:]+)(\n$|:@.+)/ && print "$2\n"' >> temp-proxy.txt
          proxy_final=$(wc -l < temp-proxy.txt)
          
          echo "âœ… Proxy domains collected:"
          echo "   GFWList: $proxy_initial domains"
          echo "   +Google: $((proxy_google - proxy_initial)) domains"
          echo "   +Apple: $((proxy_apple - proxy_google)) domains"
          echo "   +Custom: $((proxy_final - proxy_apple)) domains"
          echo "   Total: $proxy_final domains"

      - name: Reserve proxy domains from custom lists
        run: |
          echo "ğŸ“ Step 4: Reserving special proxy rules..."
          curl -sSL ${CUSTOM_PROXY} | grep -Ev ":@cn" | perl -ne '/^((full|regexp|keyword):[^:]+)(\n$|:@.+)/ && print "$1\n"' | sort --ignore-case -u > proxy-reserve.txt
          reserve_count=$(wc -l < proxy-reserve.txt)
          echo "âœ… Reserved proxy rules: $reserve_count"

      - name: Sort and generate redundant lists
        run: |
          echo "ğŸ“ Step 5: Initial sorting and dedup..."
          cat temp-proxy.txt | sort --ignore-case -u > proxy-list-with-redundant
          cat temp-direct.txt | sort --ignore-case -u > direct-list-with-redundant
          
          proxy_sorted=$(wc -l < proxy-list-with-redundant)
          direct_sorted=$(wc -l < direct-list-with-redundant)
          echo "âœ… After sorting:"
          echo "   Proxy: $proxy_sorted domains"
          echo "   Direct: $direct_sorted domains"

      - name: Remove redundant domains (Official Method)
        run: |
          echo "ğŸ”§ Step 6: Removing redundant domains (Official Method)..."
          chmod +x ./official/resouces/*.py
          
          echo "   Analyzing proxy redundancies..."
          python ./official/resouces/findRedundantDomain.py ./proxy-list-with-redundant ./proxy-list-deleted-unsort
          echo "   Analyzing direct redundancies..."
          python ./official/resouces/findRedundantDomain.py ./direct-list-with-redundant ./direct-list-deleted-unsort
          
          [ ! -f "direct-list-deleted-unsort" ] && touch direct-list-deleted-unsort
          [ ! -f "proxy-list-deleted-unsort" ] && touch proxy-list-deleted-unsort
          
          sort ./direct-list-deleted-unsort > ./direct-list-deleted-sort
          sort ./proxy-list-deleted-unsort > ./proxy-list-deleted-sort
          
          echo "   Removing redundant domains..."
          python ./official/resouces/removeFrom.py -remove ./direct-list-deleted-sort -from ./direct-list-with-redundant -out direct-list-without-redundant
          python ./official/resouces/removeFrom.py -remove ./proxy-list-deleted-sort -from ./proxy-list-with-redundant -out proxy-list-without-redundant
          
          proxy_clean=$(wc -l < proxy-list-without-redundant)
          direct_clean=$(wc -l < direct-list-without-redundant)
          proxy_removed=$(wc -l < proxy-list-deleted-sort)
          direct_removed=$(wc -l < direct-list-deleted-sort)
          
          echo "âœ… Redundancy removal complete:"
          echo "   Proxy: removed $proxy_removed redundant â†’ $proxy_clean final"
          echo "   Direct: removed $direct_removed redundant â†’ $direct_clean final"

      - name: Final processing and write to data directory
        run: |
          echo "ğŸ“ Step 7: Final processing..."
          cat direct-list-without-redundant | grep -v google | grep -v manhua | grep -v ooklaserver | grep -v "acg.rip" | sort --ignore-case -u | perl -ne '/^((?=^.{1,255})[a-zA-Z0-9][-_a-zA-Z0-9]{0,62}(\.[a-zA-Z0-9][-_a-zA-Z0-9]{0,62})*)/ && print "$1\n"' > ./community/data/cn
          cat proxy-list-without-redundant | sort --ignore-case -u | perl -ne '/^((?=^.{1,255})[a-zA-Z0-9][-_a-zA-Z0-9]{0,62}(\.[a-zA-Z0-9][-_a-zA-Z0-9]{0,62})*)/ && print "$1\n"' | perl -ne 'print if not /\.cn$/' > ./community/data/geolocation-\!cn
          
          echo "ğŸ“ Step 8: Adding reserved rules back..."
          [ -f "proxy-reserve.txt" ] && cat proxy-reserve.txt >> ./community/data/geolocation-\!cn
          
          final_cn=$(wc -l < ./community/data/cn)
          final_proxy=$(wc -l < ./community/data/geolocation-\!cn)
          
          echo "âœ… Final domain counts:"
          echo "   CN domains: $final_cn"
          echo "   Proxy domains: $final_proxy"

      - name: Build and convert geosite
        run: |
          echo "ğŸ—ï¸ Step 9: Building geosite database..."
          cd custom
          echo ipleak.net >> ../community/data/geolocation-\!cn
          echo browserleaks.org >> ../community/data/geolocation-\!cn
          
          echo "   Building geosite.dat..."
          go run ./ --datapath=../community/data
          geosite_size=$(du -h publish/geosite.dat | cut -f1)
          echo "âœ… geosite.dat built: $geosite_size"
          
          echo "   Building meta-converter..."
          cd ../converter && go build -o meta-converter .
          echo "âœ… meta-converter built"
          
          echo "   Converting geosite to meta rules..."
          mkdir -p ../meta-rule
          ./meta-converter geosite -f ../custom/publish/geosite.dat -o ../meta-rule-temp
          
          yaml_count=0
          list_count=0
          for yaml_dir in ../meta-rule-temp/*/; do
            if [[ -d "$yaml_dir" ]]; then
              dir_name=$(basename "$yaml_dir")
              if [[ -f "$yaml_dir/classical.yaml" ]]; then
                mv "$yaml_dir/classical.yaml" "../meta-rule/${dir_name}.yaml"
                yaml_count=$((yaml_count + 1))
                
                tail -n +2 "../meta-rule/${dir_name}.yaml" | sed 's/^[[:space:]]*-\s*//g' | grep -v '^$' > "../meta-rule/${dir_name}.list"
                list_count=$((list_count + 1))
                
                rule_count=$(tail -n +2 "../meta-rule/${dir_name}.yaml" | wc -l)
                echo "   âœ… $dir_name: $rule_count rules"
              fi
            fi
          done
          rm -rf ../meta-rule-temp
          
          echo "ğŸ‰ Geosite conversion complete:"
          echo "   ğŸ“„ YAML files: $yaml_count"
          echo "   ğŸ“„ LIST files: $list_count"
          echo "   ğŸ“Š Total files: $(ls ../meta-rule/*.yaml ../meta-rule/*.list 2>/dev/null | wc -l)"

      - name: Upload mihomo artifacts
        uses: actions/upload-artifact@v4
        with:
          name: mihomo-rules
          path: meta-rule/

  # Job 3: Publish (Sequential - waits for both parallel jobs)
  publish:
    runs-on: ubuntu-latest
    needs: [sing-box-rules, mihomo-rules]
    steps:
      - name: Set variables
        run: |
          echo "GOAMD64=v3" >> $GITHUB_ENV
          echo "BUILDTIME=$(TZ=Asia/Shanghai date +'%Y-%m-%d %H:%M')" >> $GITHUB_ENV
          echo "TAG_NAME=$(TZ=Asia/Shanghai date +'%Y%m%d-%H%M')" >> $GITHUB_ENV

      - name: Download sing-box artifacts
        uses: actions/download-artifact@v4
        with:
          name: sing-box-rules
          path: ./

      - name: Download mihomo artifacts
        uses: actions/download-artifact@v4
        with:
          name: mihomo-rules
          path: ./

      - name: Prepare publish artifacts
        run: |
          echo "ğŸ“¦ PREPARING UNIFIED PUBLISH"
          mkdir -p publish
          cp -r sing-rule publish/sing-rule
          cp -r sing-rule-lite publish/sing-rule-lite
          cp -r meta-rule publish/meta-rule
          echo "=== Artifact Summary ==="
          echo "Sing-box rules: $(find publish/sing-rule -type f | wc -l) files"
          echo "Sing-box lite: $(find publish/sing-rule-lite -type f | wc -l) files"
          echo "Mihomo rules: $(find publish/meta-rule -type f | wc -l) files"

      - name: Create ZIP archives
        run: |
          mkdir -p release-assets
          echo "ğŸ“¦ Creating ZIP packages"
          
          # Sing-box packages
          cd sing-rule
          if ls *.srs 1> /dev/null 2>&1; then
            zip -r ../release-assets/sing-rules-srs.zip *.srs
            echo "âœ… sing-rules-srs.zip ($(ls *.srs | wc -l) files)"
          fi
          if ls *.json 1> /dev/null 2>&1; then
            zip -r ../release-assets/sing-rules-json.zip *.json
            echo "âœ… sing-rules-json.zip ($(ls *.json | wc -l) files)"
          fi
          cd ../sing-rule-lite
          if ls *.srs 1> /dev/null 2>&1; then
            zip -r ../release-assets/sing-rules-lite-srs.zip *.srs
            echo "âœ… sing-rules-lite-srs.zip ($(ls *.srs | wc -l) files)"
          fi
          if ls *.json 1> /dev/null 2>&1; then
            zip -r ../release-assets/sing-rules-lite-json.zip *.json
            echo "âœ… sing-rules-lite-json.zip ($(ls *.json | wc -l) files)"
          fi
          
          # Mihomo packages  
          cd ../meta-rule
          if ls *.yaml 1> /dev/null 2>&1; then
            zip -r ../release-assets/meta-rules-yaml.zip *.yaml
            echo "âœ… meta-rules-yaml.zip ($(ls *.yaml | wc -l) files)"
          fi
          if ls *.list 1> /dev/null 2>&1; then
            zip -r ../release-assets/meta-rules-list.zip *.list
            echo "âœ… meta-rules-list.zip ($(ls *.list | wc -l) files)"
          fi
          if ls *.mrs 1> /dev/null 2>&1; then
            zip -r ../release-assets/meta-rules-mrs.zip *.mrs
            echo "âœ… meta-rules-mrs.zip ($(ls *.mrs | wc -l) files)"
          fi
          cd ..

      - name: Create Unified GitHub Release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: v${{ env.TAG_NAME }}
          name: ğŸš€ Parallel Build Release ${{ env.BUILDTIME }}
          body: |
            ## âš¡ å¹¶è¡Œæ„å»ºç‰ˆæœ¬ (Ultra Fast)
            
            ### ğŸ¯ Sing-box è§„åˆ™
            - `sing-rules-srs.zip` - å®Œæ•´ç‰ˆ (.srs äºŒè¿›åˆ¶)
            - `sing-rules-json.zip` - å®Œæ•´ç‰ˆ (.json æºç )
            - `sing-rules-lite-srs.zip` - ç²¾ç®€ç‰ˆ (.srs äºŒè¿›åˆ¶) - IP-CIDR + DOMAIN only
            - `sing-rules-lite-json.zip` - ç²¾ç®€ç‰ˆ (.json æºç ) - IP-CIDR + DOMAIN only
            
            ### ğŸ›¡ï¸ Mihomo è§„åˆ™
            - `meta-rules-yaml.zip` - YAML æ ¼å¼ (é»˜è®¤)
            - `meta-rules-list.zip` - LIST æ ¼å¼ (3x æ›´å¿«)
            - `meta-rules-mrs.zip` - MRS æ ¼å¼ (å®éªŒæ€§)
            
            ### âš¡ å¹¶è¡Œæ„å»ºä¼˜åŠ¿
            - ğŸš€ **2x æ„å»ºé€Ÿåº¦**: Sing-box å’Œ Mihomo å¹¶è¡Œç”Ÿæˆ
            - ğŸ¯ **èµ„æºéš”ç¦»**: æ¯ä¸ªJobç‹¬ç«‹è¿è¡Œï¼Œäº’ä¸å¹²æ‰°
            - ğŸ“Š **æ¸…æ™°æ—¥å¿—**: åˆ†Jobæ˜¾ç¤ºï¼Œé—®é¢˜å®šä½æ›´å®¹æ˜“
            - ğŸ”¥ **å®˜æ–¹ç®—æ³•**: ä½¿ç”¨MetaCubeXå®˜æ–¹é«˜æ•ˆå»é‡ç®—æ³•
            
            ### ğŸ“Š æ•°æ®æº
            - **Sing-box**: iOS rule script (~15k è§„åˆ™)
            - **Mihomo**: å¤šæºæ•´åˆ GFWList + China domains (~30k è§„åˆ™)
            
            ### ğŸ”— CDN è®¿é—®
            - GitHub: `https://raw.githubusercontent.com/proother/rule_singbox_mihomo/refs/heads/release/`
            - jsDelivr: `https://cdn.jsdelivr.net/gh/proother/rule_singbox_mihomo@release/`
          files: |
            release-assets/*.zip

      - name: Push to release branch
        run: |
          echo "ğŸŒ³ PUSHING TO BRANCHES"
          cd publish && git init && git config --local user.name "github-actions[bot]" && git config --local user.email "41898282+github-actions[bot]@users.noreply.github.com"
          git checkout -b release && git add . && git commit -m "ğŸš€ Parallel Build Released on ${{ env.BUILDTIME }}"
          git remote add origin "https://${{ github.actor }}:${{ secrets.GITHUB_TOKEN }}@github.com/${{ github.repository }}"
          git push -f -u origin release

      - name: Push to specialized branches
        run: |
          # Sing-box branch
          cd sing-rule && git init && git config --local user.name "github-actions[bot]" && git config --local user.email "41898282+github-actions[bot]@users.noreply.github.com"
          git checkout -b sing && git add . && git commit -m "ğŸ¯ Sing-box Rules (Parallel Build) ${{ env.BUILDTIME }}"
          git remote add origin "https://${{ github.actor }}:${{ secrets.GITHUB_TOKEN }}@github.com/${{ github.repository }}"
          git push -f -u origin sing
          
          # Mihomo branch
          cd ../meta-rule && git init && git config --local user.name "github-actions[bot]" && git config --local user.email "41898282+github-actions[bot]@users.noreply.github.com"
          git checkout -b meta && git add . && git commit -m "ğŸ›¡ï¸ Mihomo Rules (Parallel Build) ${{ env.BUILDTIME }}"
          git remote add origin "https://${{ github.actor }}:${{ secrets.GITHUB_TOKEN }}@github.com/${{ github.repository }}"
          git push -f -u origin meta

      - name: Purge jsDelivr CDN
        run: |
          echo "ğŸš€ Purging jsDelivr CDN"
          cd publish
          for file in $(find . -name "*.srs" -o -name "*.json" -o -name "*.yaml" -o -name "*.list" | head -30); do
            file_path=$(echo "$file" | sed 's|^\./||')
            curl -s "https://purge.jsdelivr.net/gh/${{ github.repository }}@release/${file_path}" || true
          done
          echo "âœ… CDN cache purged"
