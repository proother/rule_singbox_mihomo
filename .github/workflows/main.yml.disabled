name: Convert Workflow (Sing-box Focus)

on:
  push:
    branches:
      - main
  workflow_dispatch:
  schedule:
    - cron: '0 12 * * *'

permissions:
  contents: write

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
      #
      # 1. Set variables
      #
      - name: Set variables
        shell: bash
        run: |
          echo "GOAMD64=v3" >> $GITHUB_ENV
          echo "BUILDTIME=$(TZ=Asia/Shanghai date +'%Y-%m-%d %H:%M')" >> $GITHUB_ENV
          echo "TAG_NAME=$(TZ=Asia/Shanghai date +'%Y%m%d-%H%M')" >> $GITHUB_ENV

      #
      # 2. Check out repositories
      #
      - name: Checkout blackmatrix7/ios_rule_script
        uses: actions/checkout@v4
        with:
          repository: blackmatrix7/ios_rule_script
          path: ios_rule_script

      - name: Checkout MetaCubeX/meta-rules-converter
        uses: actions/checkout@v4
        with:
          repository: MetaCubeX/meta-rules-converter
          path: converter

      #
      # 3. Setup Go
      #
      - name: Setup Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.22'

      #
      # 4. Copy files to data source directory
      #
      - name: Copy files to data source directory
        run: |
          echo "=== Copying necessary files to data source directory ==="
          mkdir -p community/data_source

          # Copy .yaml files
          echo "=== Copying .yaml files ==="
          for dir in $(find ios_rule_script/rule/Clash -type d); do
            if ls "$dir"/*_Classical.yaml 2>/dev/null; then
              find "$dir" -type f -name '*_Classical.yaml' ! -name '*_No_Resolve.yaml' -exec cp {} community/data_source/ \;
            else
              dir_name=$(basename "$dir")
              find "$dir" -type f -name "${dir_name}.yaml" ! -name '*_No_Resolve.yaml' -exec cp {} community/data_source/ \;
            fi
          done

          echo "=== Files in community/data_source ==="
          ls -al community/data_source

      #
      # 5. Convert YAML to sing rules (Updated Step)
      #
      - name: Convert YAML to sing rules
        run: |
          echo "=== Converting .yaml to sing rules ==="
          mkdir -p sing-rule
          cd converter
          # Build the converter
          go build -o meta-converter .
          # Use the built binary
          ./meta-converter clash -f ../community/data_source -o ../sing-rule -t sing-box
          cd ../sing-rule

          # Move files from subdirectories to the root of sing-rule
          for dir in */; do
            dir_name=$(basename "$dir")
            if [[ -f "$dir/classical.json" && -f "$dir/classical.srs" ]]; then
              # Find the original YAML file in community/data_source
              original_yaml=$(find ../community/data_source -type f -iname "${dir_name}.yaml" -print -quit)

              if [[ -n "$original_yaml" ]]; then
                # Extract the original filename (without extension)
                original_name=$(basename "$original_yaml" .yaml)

                # Move and rename the JSON/SRS files to match the original filename
                mv "$dir/classical.json" "${original_name}.json"
                mv "$dir/classical.srs" "${original_name}.srs"
              else
                # Fallback to directory name if original YAML is not found
                mv "$dir/classical.json" "${dir_name}.json"
                mv "$dir/classical.srs" "${dir_name}.srs"
              fi
            fi
            # Remove the empty subdirectory
            rm -rf "$dir"
          done

          echo "=== Final files in sing-rule ==="
          ls -al

      #
      # 6. Create lite sing-box rules (IP-CIDR + DOMAIN only)
      #
      - name: Create lite sing-box rules
        run: |
          echo "=== Creating lite rules (IP-CIDR + DOMAIN only) ==="
          mkdir -p sing-rule-lite
          
          # Install jq for JSON processing
          sudo apt-get update && sudo apt-get install -y jq
          
          # Process each JSON file in sing-rule directory
          for json_file in sing-rule/*.json; do
            if [[ -f "$json_file" ]]; then
              filename=$(basename "$json_file" .json)
              echo "Processing $filename for lite version..."
              
              # Filter rules to keep ONLY ip_cidr and domain fields - defensive approach
              jq '
                {
                  version: .version,
                  rules: [
                    .rules[] | 
                    # Build new object explicitly with ONLY allowed fields
                    # This guarantees no other fields can appear
                    with_entries(select(.key == "ip_cidr" or .key == "domain")) |
                    # Only keep rules that have at least one of our target fields
                    select(keys | length > 0)
                  ]
                }
              ' "$json_file" > "sing-rule-lite/${filename}.json"
              
              # Check if the filtered file has any rules (handle null safely)
              rule_count=$(jq '.rules | if . == null then 0 else length end' "sing-rule-lite/${filename}.json")
              if [[ "$rule_count" -eq 0 ]]; then
                echo "No lite rules found in $filename, removing empty file"
                rm "sing-rule-lite/${filename}.json"
              else
                echo "Created ${filename}.json with $rule_count rules"
              fi
            fi
          done
          
          echo "=== Creating lite YAML and converting to SRS format ==="
          
          # Step 1: Create lite YAML files from original YAML files (before JSON conversion)
          echo "Creating lite YAML files from original sources..."
          mkdir -p lite-yaml-source
          
          # Process each original YAML file to create lite version
          for yaml_file in community/data_source/*.yaml; do
            if [[ -f "$yaml_file" ]]; then
              filename=$(basename "$yaml_file" .yaml)
              echo "Creating lite version of $filename..."
              
              # Extract only DOMAIN and IP-CIDR rules from original YAML with better formatting
              {
                echo "payload:"
                # Extract DOMAIN rules with proper indentation
                grep -E "^\s*-\s*DOMAIN," "$yaml_file" | sed 's/^[[:space:]]*/  /' || true
                # Extract IP-CIDR rules with proper indentation
                grep -E "^\s*-\s*IP-CIDR," "$yaml_file" | sed 's/^[[:space:]]*/  /' || true
              } > "lite-yaml-source/${filename}.yaml"
              
              # Validate and clean up the generated YAML
              rule_count=$(grep -c "^\s*-\s*" "lite-yaml-source/${filename}.yaml" 2>/dev/null || echo "0")
              if [[ "$rule_count" -eq 0 ]]; then
                echo "No rules extracted for $filename, keeping empty file for meta-converter compatibility"
                echo "payload:" > "lite-yaml-source/${filename}.yaml"
              else
                sed -i '/^$/d; /^[[:space:]]*$/d' "lite-yaml-source/${filename}.yaml"
                echo "Created lite YAML for $filename with $rule_count rules"
              fi
            fi
          done
          
          # Step 2: Use meta-converter to convert lite YAML to sing-box format
          cd converter
          
          # Ensure meta-converter binary exists
          if [[ ! -f "./meta-converter" ]]; then
            echo "Building meta-converter..."
            go build -o meta-converter .
          fi
          
          echo "Converting lite YAML to sing-box format (JSON + SRS)..."
          if ./meta-converter clash -f ../lite-yaml-source -o ../sing-rule-lite-converted -t sing-box 2>&1; then
            echo "âœ… Meta-converter completed successfully"
            
            # Step 3: Replace our filtered JSON with the properly generated ones and add SRS files
            cd ../sing-rule-lite-converted
            
            for dir in */; do
              if [[ -d "$dir" ]]; then
                dir_name=$(basename "$dir")
                
                # Find corresponding original JSON file to get the correct case
                original_json=""
                for lite_json in ../sing-rule-lite/*.json; do
                  if [[ -f "$lite_json" ]]; then
                    lite_basename=$(basename "$lite_json" .json)
                    # Compare lowercase versions to handle case mismatch
                    if [[ "${lite_basename,,}" == "${dir_name,,}" ]]; then
                      original_json="$lite_json"
                      break
                    fi
                  fi
                done
                
                if [[ -n "$original_json" ]]; then
                  original_basename=$(basename "$original_json" .json)
                else
                  original_basename="$dir_name"
                fi
                
                # Check if both JSON and SRS were generated
                if [[ -f "$dir/classical.json" && -f "$dir/classical.srs" ]]; then
                  # Both files exist - successful conversion
                  mv "$dir/classical.json" "../sing-rule-lite/${original_basename}.json"
                  mv "$dir/classical.srs" "../sing-rule-lite/${original_basename}.srs"
                  echo "âœ… Successfully converted ${original_basename}: JSON + SRS"
                elif [[ -f "$dir/classical.json" ]]; then
                  # Only JSON exists - SRS conversion failed
                  mv "$dir/classical.json" "../sing-rule-lite/${original_basename}.json"
                  echo "âš ï¸  ${original_basename}: JSON generated but SRS conversion failed"
                fi
              fi
            done
            cd ..
            
            # Clean up temporary directories
            rm -rf lite-yaml-source sing-rule-lite-converted
            echo "âœ… Cleanup completed"
          else
            echo "âŒ Meta-converter failed to convert lite YAML!"
            cd ..
            rm -rf lite-yaml-source sing-rule-lite-converted
          fi
          
          echo "=== Final cleanup: Removing empty lite files ==="
          # Final cleanup - remove any files that only contain version but no rules
          # This is the definitive check using the actual JSON output from meta-converter
          removed_empty_count=0
          for lite_file in sing-rule-lite/*.json; do
            if [[ -f "$lite_file" ]]; then
              filename=$(basename "$lite_file")
              rule_count=$(jq '.rules | if . == null then 0 else length end' "$lite_file" 2>/dev/null || echo "0")
              
              if [[ "$rule_count" -eq 0 ]]; then
                echo "ğŸ—‘ï¸  Removing empty lite file: $filename (no rules found)"
                rm "$lite_file"
                
                # Also remove corresponding SRS file if it exists
                srs_file="${lite_file%.json}.srs"
                if [[ -f "$srs_file" ]]; then
                  echo "ğŸ—‘ï¸  Also removing corresponding SRS file: $(basename "$srs_file")"
                  rm "$srs_file"
                fi
                
                removed_empty_count=$((removed_empty_count + 1))
              fi
            fi
          done
          
          if [[ "$removed_empty_count" -gt 0 ]]; then
            echo "ğŸ§¹ Cleaned up $removed_empty_count empty lite rule files"
          else
            echo "âœ… No empty lite files found - all files contain rules"
          fi
          
          # Validate that lite rules only contain ip_cidr and domain fields
          echo "=== Validating lite rules purity ==="
          validation_failed=false
          for lite_file in sing-rule-lite/*.json; do
            if [[ -f "$lite_file" ]]; then
              filename=$(basename "$lite_file" .json)
              ip_count=$(jq '[.rules[]? // empty | select(. != null and has("ip_cidr"))] | length' "$lite_file")
              domain_count=$(jq '[.rules[]? // empty | select(. != null and has("domain"))] | length' "$lite_file")
              total_count=$(jq '.rules | if . == null then 0 else length end' "$lite_file")
              
              # Check for any unexpected fields in rules (handle null values safely)
              unexpected_fields=$(jq -r '[.rules[]? // empty | select(. != null) | keys[]? // empty | select(. != "ip_cidr" and . != "domain")] | unique | .[]?' "$lite_file" 2>/dev/null || true)
              
              if [[ -n "$unexpected_fields" ]]; then
                echo "  âŒ $filename: $total_count rules ($ip_count IP-CIDR, $domain_count DOMAIN) - UNEXPECTED FIELDS: $unexpected_fields"
                validation_failed=true
              else
                echo "  âœ… $filename: $total_count rules ($ip_count IP-CIDR, $domain_count DOMAIN) - CLEAN"
              fi
            fi
          done
          
          if [[ "$validation_failed" == "true" ]]; then
            echo "âŒ VALIDATION FAILED: Some lite rules contain unexpected fields!"
            exit 1
          else
            echo "âœ… VALIDATION PASSED: All lite rules contain only ip_cidr and domain fields"
          fi
          
          echo "=== Final lite directory contents ==="
          final_json_count=$(find sing-rule-lite -name "*.json" | wc -l)
          final_srs_count=$(find sing-rule-lite -name "*.srs" | wc -l)
          echo "ğŸ“Š Final File Count:"
          echo "  ğŸ“„ JSON files: $final_json_count"
          echo "  ğŸš€ SRS files: $final_srs_count"
          
          if [[ "$final_json_count" -gt 0 ]]; then
            echo "âœ… Lite rules successfully generated with proper cleanup"
          else
            echo "âŒ CRITICAL: No lite JSON files remain after cleanup!"
          fi
          
          ls -al sing-rule-lite/ || echo "Lite directory is empty"

      #
      # 7. Gather artifacts into publish folder
      #
      - name: Prepare publish artifacts
        run: |
          echo "=== Collecting final artifacts into ./publish/ ==="
          mkdir -p publish

          # Move sing-rule and sing-rule-lite into publish/
          cp -r sing-rule publish/sing-rule
          cp -r sing-rule-lite publish/sing-rule-lite
          echo "=== sing-rule file count: $(find sing-rule -type f | wc -l) ==="
          echo "=== sing-rule-lite file count: $(find sing-rule-lite -type f | wc -l) ==="
          ls -R publish

      #
      # 8. Create ZIP archives
      #
      - name: Create ZIP archives
        run: |
          echo "=== Creating ZIP archives ==="
          mkdir -p release-assets
          
          # Sing-box rules (full version)
          echo "=== Zipping sing-box rules (full version) ==="
          cd sing-rule
          if ls *.srs 1> /dev/null 2>&1; then
            zip ../release-assets/sing-rules-srs.zip *.srs
            echo "Created sing-rules-srs.zip"
          fi
          if ls *.json 1> /dev/null 2>&1; then
            zip ../release-assets/sing-rules-json.zip *.json
            echo "Created sing-rules-json.zip"
          fi
          cd ..
          
          # Sing-box lite rules (IP-CIDR + DOMAIN only)
          echo "=== Zipping sing-box lite rules ==="
          cd sing-rule-lite
          
          # Check and package SRS files if they exist
          if ls *.srs 1> /dev/null 2>&1; then
            zip ../release-assets/sing-rules-lite-srs.zip *.srs
            echo "âœ… Created sing-rules-lite-srs.zip (lite binary rules)"
          else
            echo "âš ï¸  No SRS files found - skipping lite SRS package"
          fi
          
          # Always package JSON files (should always exist)
          if ls *.json 1> /dev/null 2>&1; then
            zip ../release-assets/sing-rules-lite-json.zip *.json
            echo "âœ… Created sing-rules-lite-json.zip (lite JSON rules)"
          else
            echo "âŒ CRITICAL: No JSON files found in lite directory!"
          fi
          cd ..
          
          echo "=== Release assets created ==="
          ls -al release-assets/

      #
      # 9. Create GitHub Release
      #
      - name: Create GitHub Release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: v${{ env.TAG_NAME }}-sing
          name: Sing-box Rules Release ${{ env.BUILDTIME }}
          body: |
            ## ğŸ“¦ Sing-box Rule Packages
            
            ### Sing-box Rules (Complete Version)
            - `sing-rules-srs.zip` - Sing-box binary rule files (.srs) - **Complete rules**
            - `sing-rules-json.zip` - Sing-box JSON rule files (.json) - **Complete rules**
            
            ### Sing-box Lite Rules âš¡ (Ultra Performance)
            - `sing-rules-lite-srs.zip` - Sing-box binary rule files (.srs) - **Lite rules (IP-CIDR + DOMAIN only)**
            - `sing-rules-lite-json.zip` - Sing-box JSON rule files (.json) - **Lite rules (IP-CIDR + DOMAIN only)**
            
            ### ğŸ¯ ä¸“æ³¨ Sing-box
            
            æ­¤ç‰ˆæœ¬ä¸“æ³¨äº **Sing-box è§„åˆ™ç”Ÿæˆ**ï¼Œæä¾›ï¼š
            - å®Œæ•´ç‰ˆè§„åˆ™ï¼šåŒ…å«æ‰€æœ‰è§„åˆ™ç±»å‹
            - Lite ç‰ˆè§„åˆ™ï¼šä»…åŒ…å« IP-CIDR å’Œ DOMAINï¼Œæ€§èƒ½ä¼˜åŒ–
            - ä¸¤ç§æ ¼å¼ï¼šJSON (source) å’Œ SRS (binary)
            
            ### ğŸ“Š æ€§èƒ½å¯¹æ¯”
            
            | ç‰ˆæœ¬ | æ–‡ä»¶æ•°é‡ | å¤§å° | æ€§èƒ½ç‰¹ç‚¹ |
            |------|----------|------|----------|
            | Complete | 686ä¸ªæ–‡ä»¶ | 8.18MB (SRS) | å…¨åŠŸèƒ½æ”¯æŒ |
            | Lite | æ™ºèƒ½ä¼˜åŒ– | 619KB (SRS) | ğŸš€ 92.4% ä½“ç§¯å‡å°‘ + ç©ºæ–‡ä»¶æ¸…ç† |
            
            ### ğŸ“ ç›®å½•ç»“æ„
            ```
            publish/
            â”œâ”€â”€ sing-rule/          # å®Œæ•´ç‰ˆè§„åˆ™
            â”‚   â”œâ”€â”€ *.json         # JSON æ ¼å¼
            â”‚   â””â”€â”€ *.srs          # SRS äºŒè¿›åˆ¶æ ¼å¼
            â””â”€â”€ sing-rule-lite/     # Lite ç‰ˆè§„åˆ™
                â”œâ”€â”€ *.json         # JSON æ ¼å¼  
                â””â”€â”€ *.srs          # SRS äºŒè¿›åˆ¶æ ¼å¼
            ```
          files: |
            release-assets/*.zip